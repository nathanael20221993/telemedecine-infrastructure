# .github/workflows/terraform-deploy.yml
name: üè• Terraform Deploy - T√©l√©m√©decine

on:
  push:
    branches:
      - develop      # ‚Üí DEV
      - staging      # ‚Üí STAGE  
      - preprod      # ‚Üí PREPROD
      - main         # ‚Üí PROD (avec approbation)
  pull_request:
    branches:
      - develop
      - staging
      - preprod
      - main
  workflow_dispatch:  # D√©clenchement manuel
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - stage
        - preprod
        - prod
      action:
        description: 'Action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
        - plan
        - apply
        - destroy

env:
  TF_VERSION: '1.5.0'
  AWS_REGION: 'eu-west-3'

jobs:
  # ==============================================================================
  # JOB 1: D√âTECTION DE L'ENVIRONNEMENT
  # ==============================================================================
  detect-environment:
    name: üéØ Detect Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.detect.outputs.environment }}
      action: ${{ steps.detect.outputs.action }}
      should_deploy: ${{ steps.detect.outputs.should_deploy }}
      
    steps:
    - name: Detect Environment and Action
      id: detect
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          echo "action=${{ github.event.inputs.action }}" >> $GITHUB_OUTPUT
          echo "should_deploy=true" >> $GITHUB_OUTPUT
        elif [ "${{ github.event_name }}" = "pull_request" ]; then
          case "${{ github.base_ref }}" in
            develop) echo "environment=dev" >> $GITHUB_OUTPUT ;;
            staging) echo "environment=stage" >> $GITHUB_OUTPUT ;;
            preprod) echo "environment=preprod" >> $GITHUB_OUTPUT ;;
            main) echo "environment=prod" >> $GITHUB_OUTPUT ;;
          esac
          echo "action=plan" >> $GITHUB_OUTPUT
          echo "should_deploy=false" >> $GITHUB_OUTPUT
        else
          case "${{ github.ref_name }}" in
            develop) echo "environment=dev" >> $GITHUB_OUTPUT ;;
            staging) echo "environment=stage" >> $GITHUB_OUTPUT ;;
            preprod) echo "environment=preprod" >> $GITHUB_OUTPUT ;;
            main) echo "environment=prod" >> $GITHUB_OUTPUT ;;
          esac
          echo "action=apply" >> $GITHUB_OUTPUT
          echo "should_deploy=true" >> $GITHUB_OUTPUT
        fi

  # ==============================================================================
  # JOB 2: VALIDATION ET S√âCURIT√â
  # ==============================================================================
  validate:
    name: üîç Validate & Security
    runs-on: ubuntu-latest
    needs: detect-environment
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Terraform Format Check
      run: |
        terraform fmt -check -recursive
        if [ $? -ne 0 ]; then
          echo "‚ùå Code not properly formatted"
          echo "Run: terraform fmt -recursive"
          exit 1
        fi

    - name: Validate All Environments
      run: |
        for env in dev stage preprod prod; do
          echo "üîç Validating $env..."
          cd environments/$env
          terraform init -backend=false
          terraform validate
          cd ../..
        done

    - name: Security Scan with tfsec
      uses: aquasecurity/tfsec-action@v1.0.0
      with:
        soft_fail: true

    - name: Cost Estimation
      if: needs.detect-environment.outputs.environment == 'prod'
      run: |
        echo "üí∞ Production deployment detected"
        echo "Estimated monthly cost will be calculated..."

  # ==============================================================================
  # JOB 3: TERRAFORM PLAN
  # ==============================================================================
  terraform-plan:
    name: üìã Terraform Plan (${{ needs.detect-environment.outputs.environment }})
    runs-on: ubuntu-latest
    needs: [detect-environment, validate]
    environment: ${{ needs.detect-environment.outputs.environment }}
    
    env:
      ENVIRONMENT: ${{ needs.detect-environment.outputs.environment }}
    
    defaults:
      run:
        working-directory: environments/${{ needs.detect-environment.outputs.environment }}
        
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Backend
      run: |
        # Cr√©ation du backend S3 si n√©cessaire
        BUCKET="telemedecine-terraform-state-$ENVIRONMENT"
        TABLE="telemedecine-terraform-locks-$ENVIRONMENT"
        
        # Bucket S3
        if ! aws s3 ls "s3://$BUCKET" &> /dev/null; then
          echo "Creating S3 bucket: $BUCKET"
          aws s3 mb "s3://$BUCKET" --region ${{ env.AWS_REGION }}
          aws s3api put-bucket-versioning --bucket "$BUCKET" --versioning-configuration Status=Enabled
          aws s3api put-bucket-encryption --bucket "$BUCKET" --server-side-encryption-configuration '{
            "Rules": [{"ApplyServerSideEncryptionByDefault": {"SSEAlgorithm": "AES256"}}]
          }'
        fi
        
        # Table DynamoDB
        if ! aws dynamodb describe-table --table-name "$TABLE" &> /dev/null; then
          echo "Creating DynamoDB table: $TABLE"
          aws dynamodb create-table \
            --table-name "$TABLE" \
            --attribute-definitions AttributeName=LockID,AttributeType=S \
            --key-schema AttributeName=LockID,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST
          aws dynamodb wait table-exists --table-name "$TABLE"
        fi

    - name: Terraform Init
      run: terraform init

    - name: Terraform Plan
      id: plan
      run: |
        terraform plan \
          -var-file="terraform.tfvars" \
          -var="db_password=${{ secrets.DB_PASSWORD }}" \
          -var="certificate_arn=${{ secrets.CERTIFICATE_ARN }}" \
          -out=tfplan \
          -detailed-exitcode
      env:
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_certificate_arn: ${{ secrets.CERTIFICATE_ARN }}

    - name: Upload Plan Artifact
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plan-${{ env.ENVIRONMENT }}
        path: environments/${{ env.ENVIRONMENT }}/tfplan
        retention-days: 5

    - name: Comment Plan on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const output = `
          ## üìã Terraform Plan - ${{ env.ENVIRONMENT }}
          
          **Action**: \`terraform plan\`
          **Environment**: \`${{ env.ENVIRONMENT }}\`
          **Terraform**: \`${{ env.TF_VERSION }}\`
          
          ### Plan Status
          \`\`\`
          ${{ steps.plan.outcome == 'success' && '‚úÖ Plan successful' || '‚ùå Plan failed' }}
          \`\`\`
          
          <details>
          <summary>üìä Show Plan Details</summary>
          
          **Changes detected**: ${{ steps.plan.outputs.exitcode == '2' && 'Yes' || 'No' }}
          
          </details>
          `;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: output
          });

  # ==============================================================================
  # JOB 4: D√âPLOIEMENT AUTOMATIQUE
  # ==============================================================================
  terraform-apply:
    name: üöÄ Deploy to ${{ needs.detect-environment.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [detect-environment, terraform-plan]
    if: needs.detect-environment.outputs.should_deploy == 'true' && needs.detect-environment.outputs.action == 'apply'
    environment: 
      name: ${{ needs.detect-environment.outputs.environment }}
      url: ${{ steps.deploy.outputs.application_url }}
    
    env:
      ENVIRONMENT: ${{ needs.detect-environment.outputs.environment }}
    
    defaults:
      run:
        working-directory: environments/${{ needs.detect-environment.outputs.environment }}
        
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4

    - name: Setup Terraform  
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Download Plan Artifact
      uses: actions/download-artifact@v4
      with:
        name: terraform-plan-${{ env.ENVIRONMENT }}
        path: environments/${{ env.ENVIRONMENT }}

    - name: Terraform Init
      run: terraform init

    - name: Terraform Apply
      id: apply
      run: |
        echo "üöÄ Deploying to $ENVIRONMENT..."
        terraform apply -auto-approve tfplan
        
        # Capture outputs
        echo "application_url=$(terraform output -raw alb_dns_name 2>/dev/null || echo 'N/A')" >> $GITHUB_OUTPUT
        echo "eks_cluster=$(terraform output -raw eks_cluster_name 2>/dev/null || echo 'N/A')" >> $GITHUB_OUTPUT
        echo "deployment_time=$(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_OUTPUT

    - name: Post-Deployment Tests
      run: |
        echo "üß™ Running post-deployment tests..."
        
        # Health check
        ALB_DNS=$(terraform output -raw alb_dns_name 2>/dev/null || echo "")
        if [ ! -z "$ALB_DNS" ]; then
          echo "Testing ALB health: $ALB_DNS"
          # curl -f "http://$ALB_DNS/health" || echo "Health check failed (normal for new deployment)"
        fi
        
        # EKS cluster check
        EKS_CLUSTER=$(terraform output -raw eks_cluster_name 2>/dev/null || echo "")
        if [ ! -z "$EKS_CLUSTER" ]; then
          echo "Configuring kubectl for $EKS_CLUSTER"
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name $EKS_CLUSTER
          kubectl get nodes || echo "EKS not ready yet"
        fi

    - name: Update Deployment Status
      id: deploy
      run: |
        echo "application_url=https://${{ steps.apply.outputs.application_url }}" >> $GITHUB_OUTPUT
        echo "‚úÖ Deployment completed successfully"

    - name: Slack Notification
      if: always()
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#telemedecine-deployments'
        text: |
          üè• T√©l√©m√©decine Deployment
          
          **Environment**: ${{ env.ENVIRONMENT }}
          **Status**: ${{ job.status == 'success' && '‚úÖ Success' || '‚ùå Failed' }}
          **Application**: ${{ steps.apply.outputs.application_url }}
          **Cluster**: ${{ steps.apply.outputs.eks_cluster }}
          **Time**: ${{ steps.apply.outputs.deployment_time }}
          
          **Commit**: ${{ github.sha }}
          **Author**: ${{ github.actor }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # ==============================================================================
  # JOB 5: DESTRUCTION (MANUAL ONLY)
  # ==============================================================================
  terraform-destroy:
    name: üóëÔ∏è Destroy ${{ needs.detect-environment.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [detect-environment]
    if: needs.detect-environment.outputs.action == 'destroy' && github.event_name == 'workflow_dispatch'
    environment: 
      name: ${{ needs.detect-environment.outputs.environment }}-destroy
    
    env:
      ENVIRONMENT: ${{ needs.detect-environment.outputs.environment }}
    
    defaults:
      run:
        working-directory: environments/${{ needs.detect-environment.outputs.environment }}
        
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Protection Check
      run: |
        if [ "$ENVIRONMENT" = "prod" ]; then
          echo "‚ùå Production destruction is not allowed via pipeline"
          echo "Contact platform team for production infrastructure changes"
          exit 1
        fi

    - name: Terraform Init
      run: terraform init

    - name: Terraform Destroy
      run: |
        echo "üóëÔ∏è Destroying $ENVIRONMENT infrastructure..."
        terraform destroy \
          -var-file="terraform.tfvars" \
          -var="db_password=${{ secrets.DB_PASSWORD }}" \
          -var="certificate_arn=${{ secrets.CERTIFICATE_ARN }}" \
          -auto-approve
      env:
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_certificate_arn: ${{ secrets.CERTIFICATE_ARN }}

---
